function C(){const h=new WebSocket(`ws://${location.host}`);h.onopen=()=>setInterval(()=>h.send("ping"),5000),h.onmessage=(J)=>{if(J.data!=="Well received")console.log(J.data);if(J.data==="reload")location.reload()}}function o(...h){const J=[];for(let M of h){const W=document.getElementById(M);if(W===null)return console.error(`Cannot get any HTML Element given the "${M}" id`),null;J.push(W)}return J}function B(h){const J=o(h.canvasId,h.solutionSpaceSizePId,h.resetBtnId,h.gtBtnId,h.btBtnId,h.ncCheckboxId,h.acNoneRadioId,h.ac1RadioId,h.ac3RadioId,h.testedSolutionsPId,h.prunedSolutionsPId,h.progressPId,h.timeleftPId);if(J===null)return null;return{canvas:J[0],solutionSpaceSizeP:J[1],resetBtn:J[2],gtBtn:J[3],btBtn:J[4],ncCheckbox:J[5],acNoneRadio:J[6],ac1Radio:J[7],ac3Radio:J[8],testedSolutionsP:J[9],prunedSolutionsP:J[10],progressP:J[11],timeleftP:J[12]}}function S(h){h.elements.canvas.onmousemove=(J)=>{J.stopPropagation();const{offsetX:M,offsetY:W}=J,q=Math.min(Math.floor(M/h.ui.cellSize),8),Q=Math.min(Math.floor(W/h.ui.cellSize),8),Y=h.getSelectedCell();document.onclick=()=>{if(Y===null||Y[0]!==q||Y[1]!==Q)h.setSelectedCell([q,Q]),h.refreshGrid()}},h.elements.canvas.onmouseout=(J)=>{if(J.stopPropagation(),h.getSelectedCell()!==null)h.setSelectedCell(null),h.refreshGrid()},document.onkeyup=(J)=>{if(J.stopPropagation(),J.key>="1"&&J.key<="9"&&h.getSelectedCell()!==null){const M=parseInt(J.key);if(M%1===0)h.toggle(M)}},h.elements.resetBtn.onclick=(J)=>{h.app.reset()},h.elements.gtBtn.onclick=(J)=>{h.app.reset(),h.app.launchGTSolve()}}function c(h){h.canvas.onmousemove=null,h.canvas.onmouseout=null,document.onkeyup=null}class _{h;J;M;W;q;Q;constructor(h,J,M,W,q,Q){this._app=h;this._solutionSpaceSizeP=J;this._testedSolutionsP=M;this._prunedSolutionsP=W;this._progressP=q;this._timeleftP=Q}display(){const h=this._app.solutionSpaceSize;if(typeof h==="undefined")return;this._solutionSpaceSizeP.innerText=`${h} solutions possibles.`;const{start:J,tested:M,pruned:W}=this._app.stats;this._testedSolutionsP.innerText=`${M} solutions test\xE9es.`,this._prunedSolutionsP.innerText=`${W} solutions \xE9lagu\xE9es.`}static create(h){return new _(h.app,h.solutionSpaceSizeP,h.testedSolutionsP,h.prunedSolutionsP,h.progressP,h.timeleftP)}}var F=getComputedStyle(document.documentElement);class K{h;J;static _ui=new WeakMap;_cellSize;static colorBackground=F.getPropertyValue("--neutral-white");static colorBackgroundHighlight=F.getPropertyValue("--brand-uno-background");static colorSelected=F.getPropertyValue("--brand-uno-hover");static colorText=F.getPropertyValue("--brand-uno");static colorTextLight=F.getPropertyValue("--brand-uno-light");static colorBorder=F.getPropertyValue("--sudoku-border");static colorBorderBold=F.getPropertyValue("--brand-uno");static colorSuccess=F.getPropertyValue("--signal-success");static colorSuccessBackground=F.getPropertyValue("--signal-success-background");static font=F.getPropertyValue("--font-family-primary");constructor(h,J){this._canvas=h;this._ctx=J;this._cellSize=Math.round(Math.min(h.width,h.height)/9)}static get(h){if(K._ui.has(h))return K._ui.get(h);const J=h.getContext("2d");if(J===null)return!1;const M=new K(h,J);return K._ui.set(h,M),M}get width(){return this._canvas.width}get height(){return this._canvas.height}get cellSize(){return this._cellSize}clearCanvas(){return this._ctx.fillStyle=K.colorBackground,this._ctx.fillRect(0,0,this.width,this.height),this}drawCell(h,J,M=this._cellSize,W=K.thinLineColor,q){const Q=h*M,Y=J*M;if(q)this._ctx.fillStyle=q,this._ctx.fillRect(Q+1,Y+1,M-2,M-2);return this._ctx.strokeStyle=W,this._ctx.strokeRect(Q,Y,M,M),this}drawRow(h,J){for(let M=0;M<9;M++)this.drawCell(M,h,this._cellSize,K.colorBorder,J);return this}drawColumn(h,J){for(let M=0;M<9;M++)this.drawCell(h,M,this._cellSize,K.colorBorder,J);return this}drawGroup(h,J,M){this.drawCell(h,J,this._cellSize*3,K.colorBorderBold,M);for(let W=0;W<3;W++)for(let q=0;q<3;q++)this.drawCell(h*3+W,J*3+q,this._cellSize,K.colorBorder);return this}drawCellValue(h,J,M){this._ctx.fillStyle=K.colorText,this._ctx.font=`600 48px ${K.font}`,this._ctx.textBaseline="middle",this._ctx.textAlign="center";const W=h*this._cellSize+Math.floor(this._cellSize*0.5),q=J*this._cellSize+Math.floor(this._cellSize*0.575);return this._ctx.fillText(M.toString(),W,q),this}drawCellDomain(h,J,M){this._ctx.fillStyle=K.colorTextLight,this._ctx.font=`400 14px ${K.font}`,this._ctx.textBaseline="top",this._ctx.textAlign="start";const W=Math.max(this._cellSize-2,Math.floor(this._cellSize*0.8)),q=Math.floor(W/3),Q=Math.max(1,Math.floor(this._cellSize*0.1)),Y=h*this._cellSize+Q,$=J*this._cellSize+Q;for(let L=1;L<=9;L++){const T=M.has(L)?L:null,A=(L-1)%3,x=Math.floor((L-1)/3),E=Y+q*A,k=$+q*x;this._ctx.fillText(T!==null?T.toString():"",E,k)}return this}drawEmptyGrid(){this.clearCanvas();for(let h=0;h<3;h++)for(let J=0;J<3;J++)this.drawGroup(h,J);return this}colorizeSelectedStuff(h){if(h===null)return this;const J=[Math.floor(h[0]/3),Math.floor(h[1]/3)];return this.drawRow(h[1],K.colorBackgroundHighlight).drawColumn(h[0],K.colorBackgroundHighlight).drawGroup(J[0],J[1],K.colorBackgroundHighlight).drawCell(h[0],h[1],this._cellSize,K.colorBorder,K.colorSelected),this}drawVictory(){return this._ctx.fillStyle=K.colorSuccessBackground,this._ctx.fillRect(0,0,this.width,this.height),this._ctx.fillStyle=K.colorSuccess,this._ctx.font=`600 72px ${K.font}`,this._ctx.textBaseline="middle",this._ctx.textAlign="center",this._ctx.fillText("Victory !".toUpperCase(),this._canvas.width/2,this._canvas.height/2),this}}function P(h,J){return z.fromJSON(h,J)}function j(h){return z.getByName(h)}class z{static domains=new Map;_values;constructor(h=[]){this._values=new Set(h)}add(h){this._values.add(h)}del(h){this._values.delete(h)}has(h){return this._values.has(h)}copy(h){const J=new z(this.toJSON());return z.domains.set(h,J),J}toJSON(){const h=[];for(let J of this._values)h.push(J);return h}getSize(){return this._values.size}static validateJSON(h){if(Array.isArray(h)&&h.length>0){const J=typeof h[0];if(!h.reduce((W,q)=>W&&typeof q===J,!0))return!1}return!0}static fromJSON(h,J){if(z.validateJSON(J)){const M=new z(J);return z.domains.set(h,M),M}throw new Error("At least one element do not have the same type as the other")}static getByName(h){return z.domains.get(h)}}function D(h,J){return g.fromJSON(h,J)}function G(h){return g.getByName(h)}class g{h;J;M;static variables=new Map;_value;constructor(h,J,M){this._name=h;this._domainName=J;this._domain=M}get name(){return this._name}get domain(){return this._domain}get value(){return this._value}set(h){if(this._domain.has(h))this._value=h}unset(){this._value=void 0}isSet(){return typeof this._value!=="undefined"}toJSON(){const h={domain:this._domainName};if(this.isSet())h.value=this._value;return h}static fromJSON(h,J){const M=j(J.domain);if(typeof M==="undefined")throw new Error(`The variable "${h}" reference an unknown domain "${J.domain}"`);const W=new g(h,J.domain,M.copy(`${h}-domain`));return g.variables.set(h,W),W}static getByName(h){return g.variables.get(h)}}class X{h;static constraints=new Map;constructor(h){this._name=h}get name(){return this._name}static getByName(h){return X.constraints.get(h)}}class w extends X{J;M;static type="intension";static arity=1;constructor(h,J,M){super(h);this._v=J;this._checkConsistency=M}get type(){return w.type}get arity(){return w.arity}get variableName(){return this._v.name}checkConsistency(){return this._v.isSet()&&this._checkConsistency(this._v.value)}toJSON(){return{type:w.type,arity:w.arity,variable:this._v.name,valueConsistency:this._checkConsistency.toString()}}static create(h,J){const M=G(J.variable);if(!M)throw new Error(`The constraint "${h}" refer to an unknown variable "${J.variable}"`);const W=new w(h,M,J.valueConsistency);return X.constraints.set(h,W),W}static fromJSON(h,J){const M=new Function(`return ${J.valueConsistency}`)(),W={...J,valueConsistency:M};return w.create(h,W)}}class O extends X{J;static type="extension";static arity=1;_index;_areSupports;_areConflicts;constructor(h,J,M,W){super(h);this._v=J;this._index=new Set(M.filter((q)=>J.domain.has(q))),this._areSupports=W==="supports",this._areConflicts=W==="conflicts"}get type(){return O.type}get arity(){return O.arity}get variableName(){return this._v.name}checkConsistency(){if(!this._v.isSet())return!1;return this._index.has(this._v.value)?this._areSupports:this._areConflicts}toJSON(){const h=[];for(let J of this._index.values())h.push(J);return{type:O.type,arity:O.arity,variable:this._v.name,values:h,valuesType:this._areSupports?"supports":"conflicts"}}static create(h,J){const M=G(J.variable);if(!M)throw new Error(`The constraint "${h}" refer to an unknown variable "${J.variable}"`);const W=new O(h,M,J.values,J.valuesType);return X.constraints.set(h,W),W}static fromJSON(h,J){return O.create(h,J)}}function i(h){return h.type===w.type}function s(h){return h.type===w.type}function d(h,J){return i(J)?w.fromJSON(h,J):O.fromJSON(h,J)}function v(h,J){return s(J)?w.create(h,J):O.create(h,J)}var U=1;class H extends X{J;M;static type="intension";static arity=2;constructor(h,J,M){super(h);this._v=J;this._checkConsistency=M}get type(){return H.type}get arity(){return H.arity}get variableNames(){return[this._v[0].name,this._v[1].name]}checkConsistency(){const[h,J]=this._v;return h.isSet()&&J.isSet()&&this._checkConsistency(h.value,J.value)}toJSON(){return{type:H.type,arity:H.arity,variables:this.variableNames,valuesConsistency:this._checkConsistency.toString()}}static create(h,J){const[M,W]=J.variables,q=G(M),Q=G(W);if(!(q&&Q))throw new Error(`The constraint "${h}" refers to the variables "${M}" and "${W}" but one of them is unknown`);const Y=new H(h,[q,Q],J.valuesConsistency);return X.constraints.set(h,Y),Y}static fromJSON(h,J){const M=new Function(`return ${J.valuesConsistency}`)(),W={...J,valuesConsistency:M};return H.create(h,W)}}class R extends X{J;static type="extension";static arity=2;_index;_areSupports;_areConflicts;constructor(h,J,M,W){super(h);this._v=J;const q=M.filter((Q)=>J[0].domain.has(Q[0])&&J[1].domain.has(Q[1]));this._index=new Map;for(let Q=0;Q<q.length;Q++){const[Y,$]=q[Q];if(!this._index.has(Y))this._index.set(Y,new Set);this._index.get(Y).add($)}this._areSupports=W==="supports",this._areConflicts=W==="conflicts"}get type(){return R.type}get arity(){return R.arity}get variableNames(){return[this._v[0].name,this._v[1].name]}checkConsistency(){const[h,J]=this._v;if(!(h.isSet()&&J.isSet()))return!1;const M=this._index.get(h.value);return M&&M.has(J.value)?this._areSupports:this._areConflicts}toJSON(){const h=[];for(let J of this._index.keys())for(let M of this._index.get(J).values())h.push([J,M]);return{type:R.type,arity:R.arity,variables:this.variableNames,tuples:h,tuplesType:this._areSupports?"supports":"conflicts"}}static create(h,J){const[M,W]=J.variables,q=G(M),Q=G(W);if(!(q&&Q))throw new Error(`The constraint "${h}" refers to the variables "${M}" and "${W}" but one of them is unknown`);const Y=new R(h,[q,Q],J.tuples,J.tuplesType);return X.constraints.set(h,Y),Y}static fromJSON(h,J){return R.create(h,J)}}function a(h){return h.type===H.type}function e(h){return h.type===H.type}function p(h,J){return a(J)?H.fromJSON(h,J):R.fromJSON(h,J)}function u(h,J){return e(J)?H.create(h,J):R.create(h,J)}function n(h){return h.arity===U}function hh(h){return h.arity===U}function m(h,J){return n(J)?d(h,J):p(h,J)}function f(h,J){return hh(J)?v(h,J):u(h,J)}class V{h;J;M;W;_solutionSpaceSize;constructor(h,J,M,W){this._name=h;this._domains=J;this._variables=M;this._constraints=W;this._solutionSpaceSize=this.computeSolutionSpaceSize()}get name(){return this._name}get solutionsSpaceSize(){return this._solutionSpaceSize}get domains(){return this._domains}get variables(){return this._variables}get constraints(){return this._constraints}static bigintRatio(h,J){const M=this.simplifyFraction(h,J);return M[0]<=Number.MAX_SAFE_INTEGER&&M[1]<=Number.MAX_SAFE_INTEGER?Number(M[0])/Number(M[1]):M}computeSolutionSpaceSize(){let h=1n,J=0n;for(let M of this._variables.values())J=h*BigInt(M.domain.getSize()),h=J;return J}static pgcd(h,J){if(h===0n||J===0n)return 1n;const M=h>J?h:J,W=h<=J?h:J,q=M/W,Q=M%W;return Q===0n?q:this.pgcd(q,Q)}static simplifyFraction(h,J){let M=h,W=J,q=this.pgcd(M,W);while(q>1n)M=M/q,W=W/q,q=this.pgcd(M,W);return[M,W]}toJSON(){const h={};for(let[W,q]of this._domains.entries())h[W]=q.toJSON();const J={};for(let[W,q]of this._variables.entries())J[W]=q.toJSON();const M={};for(let[W,q]of this._constraints.entries())M[W]=q.toJSON();return{name:this._name,domains:h,variables:J,constraints:M}}setAffectation(h){for(let J in h){const M=this._variables.get(J),W=h[J];if(M?.domain.has(W))M.set(W)}}unsetAffectation(h){for(let J in h){const M=this._variables.get(J);if(M?.isSet())M.unset()}}static propsToDomains(h){const J=new Map;for(let M in h.domains)J.set(M,P(M,h.domains[M]));return J}static propsToVariables(h){const J=new Map;for(let M in h.variables)J.set(M,D(M,h.variables[M]));return J}static propsToConstraints(h){const J=new Map;for(let M in h.constraints)J.set(M,m(M,h.constraints[M]));return J}static fromJSON(h){return new V(h.name,V.propsToDomains(h),V.propsToVariables(h),V.propsToConstraints(h))}}class y{h;_workingProblem;_solving=!1;constructor(h){this._initialProblem=h}get solving(){return this._solving}copyProblem(h){const J=h.toJSON();return V.fromJSON(J)}*_gtAffectation(){const h=[];for(let q of this._workingProblem.variables.keys())h.push(q);const J=[];for(let q of h){const Y=this._workingProblem.variables.get(q).domain.toJSON();if(Y.length===0)return;J.push([q,0,Y])}const M=J.reduce((q,[Q,Y,$])=>q+$.length,0);let W=0;while(W<M&&this._solving){const q={};for(let[Q,Y,$]of J)q[Q]=$[Y];yield q,W=0;for(let Q=J.length-1;Q>=0;Q--){const[Y,$,L]=J[Q];if($<L.length-1){J[Q][1]++,W+=J[Q][1];break}else J[Q][1]=0}}}*gt(h=!0,J=!1){this._solving=!0,this._workingProblem=this.copyProblem(this._initialProblem);for(let M of this._gtAffectation()){if(!this._solving)return;const W=this._gtIsConsistent(M);if(W||J)yield[M,W];if(W&&h)return}}_gtIsConsistent(h){if(!this._workingProblem)return!1;this._workingProblem.setAffectation(h);for(let J of this._workingProblem.constraints.values())if(!J.checkConsistency())return!1;return this._workingProblem.unsetAffectation(h),!0}stop(){this._solving=!1}static create(h){return new y(h.problem)}}class Z extends V{q;static baseCellDomain=P("baseCellDomain",[1,2,3,4,5,6,7,8,9]);static mustBeDifferent=(h,J)=>h!==J;constructor(h,J,M,W,q){super(h,J,M,W);this._ui=q}static prepareDomains(){const h=new Map,J=[];for(let M=0;M<9;M++){const W=[];for(let q=0;q<9;q++){const Q=`d:${q}x${M}`,Y=Z.baseCellDomain.copy(Q);h.set(Q,Y),W.push(Q)}J.push(W)}return[h,J]}static vName(h,J){return`cell${h}x${J}`}static prepareVariables(h){const J=[],M=new Map;for(let W=0;W<9;W++){const q=[];for(let Q=0;Q<9;Q++){const Y=h[W][Q],$=Z.vName(Q,W),L=D($,{domain:Y});M.set($,L),q.push($)}J.push(q)}return[M,J]}static rule(h,J){return{type:"intension",arity:2,variables:[h,J],valuesConsistency:Z.mustBeDifferent}}static prepareConstraints(h){const J=new Map;for(let M=0;M<9;M++)for(let W=0;W<9;W++)for(let q=W+1;q<9;q++){let Q=`c:${W}x${M}->${q}x${M}`,Y=Z.rule(h[M][W],h[M][q]),$=f(Q,Y);J.set(Q,$),Q=`c:${M}x${W}->${M}x${q}`,Y=Z.rule(h[W][M],h[q][M]),$=f(Q,Y),J.set(Q,$)}for(let M=0;M<9;M++){const W=M%3,q=(M-W)/3%3;for(let Q=0;Q<9;Q++){const Y=Q%3,$=W+Y,L=(Q-Y)/3%3,T=q+L;for(let A=Q;A<9;A++){const x=A%3,E=W+x,k=(A-x)/3%3,I=q+k,b=`c:${$}x${T}->${E}x${I}`,l=Z.rule(h[T][$],h[I][E]),t=f(b,l);J.set(b,t)}}}return J}static create(h){const[J,M]=Z.prepareDomains(),[W,q]=Z.prepareVariables(M),Q=Z.prepareConstraints(q);return new Z(h.name,J,W,Q,h.ui)}_getVariable(h,J){const M=Z.vName(h,J);return this._variables.get(M)}_drawCellContent(h,J){const M=this._getVariable(h,J);if(M)if(M.isSet())this._ui.drawCellValue(h,J,M.value);else this._ui.drawCellDomain(h,J,M.domain)}cellIsSet(h,J){return this._getVariable(h,J)?.isSet()??!1}domainHas(h,J,M){return this._getVariable(h,J)?.domain.has(M)??!1}drawCellsContent(){for(let h=0;h<9;h++)for(let J=0;J<9;J++)this._drawCellContent(J,h)}setCellValue(h,J,M){this._getVariable(h,J)?.set(M)}unsetCellValue(h,J){this._getVariable(h,J)?.unset()}getCellValue(h,J){return this._getVariable(h,J)?.value}_removeValue(h,J,M){this._getVariable(h,J)?.domain.del(M)}_addValue(h,J,M){this._getVariable(h,J)?.domain.add(M)}maintainImpactedCellsDomain(h,J,M,W){const q=W?this._removeValue.bind(this):this._addValue.bind(this);for(let $=0;$<9;$++){if($!==h)q&&q($,J,M);if($!==J)q&&q(h,$,M)}const Q=Math.floor(h/3),Y=Math.floor(J/3);for(let $=0;$<3;$++)for(let L=0;L<3;L++){const T=Q*3+L,A=Y*3+$;if(T!==h&&A!==J)q&&q(T,A,M)}}}class N{h;J;selectedCell=null;_problem;_statsDisplay;_solver;_iterationsMin=0;_iterationsMax=0;_lastTime=0;_startTime=0;_minDt=Number.MAX_SAFE_INTEGER;_handleRefreshStats=null;_solverSteps;_testedSolutions=0n;_prunedSolutions=0n;_gtIterator=null;constructor(h,J){this._ui=h;this._elements=J}get solutionSpaceSize(){return this._problem?.solutionsSpaceSize}get stats(){return{start:this._startTime,tested:this._testedSolutions,pruned:this._prunedSolutions}}_refreshGrid(){this._ui.drawEmptyGrid().colorizeSelectedStuff(this.selectedCell),this._problem?.drawCellsContent()}_toggle(h){if(!this._problem)return;const[J,M]=this.selectedCell;if(!this._problem.cellIsSet(J,M)){if(this._problem?.domainHas(J,M,h)??!1)this._problem?.setCellValue(J,M,h),this._problem?.maintainImpactedCellsDomain(J,M,h,!0),this._refreshGrid()}else if(this._problem?.getCellValue(J,M)===h){this._problem?.unsetCellValue(J,M),this._problem?.maintainImpactedCellsDomain(J,M,h,!1);for(let W=0;W<9;W++)for(let q=0;q<9;q++)if(this._problem?.getCellValue(q,W)===h)this._problem?.maintainImpactedCellsDomain(q,W,h,!0);this._refreshGrid()}}start(){if(S({app:this,elements:this._elements,ui:this._ui,refreshGrid:this._refreshGrid.bind(this),toggle:this._toggle.bind(this),getSelectedCell:()=>this.selectedCell,setSelectedCell:(h)=>this.selectedCell=h}),this._problem=Z.create({name:`sudoku-${Date.now()}`,ui:this._ui}),this._refreshGrid(),!this._solver)this._solver=y.create({problem:this._problem});if(typeof this._statsDisplay==="undefined")this._statsDisplay=_.create({app:this,solutionSpaceSizeP:this._elements.solutionSpaceSizeP,testedSolutionsP:this._elements.testedSolutionsP,prunedSolutionsP:this._elements.prunedSolutionsP,progressP:this._elements.progressP,timeleftP:this._elements.timeleftP});this._statsDisplay.display()}stop(){if(this._solver?.stop(),this._gtIterator=null,this._lastTime=0,this._solverSteps=void 0,c(this._elements),this._elements.ncCheckbox.checked=!1,this._elements.acNoneRadio.checked=!0,this._handleRefreshStats!==null)clearInterval(this._handleRefreshStats),this._handleRefreshStats=null}reset(){this.stop(),this.start()}_computeSolvingIterations(h){const J=h-this._lastTime;if(J*0.9<=this._minDt/2)this._iterationsMax*=2,this._iterationsMin*=2;else if(J*0.9<=this._minDt)this._iterationsMin=Math.floor(this._iterationsMin*1.5),this._iterationsMax=Math.max(this._iterationsMin+1,this._iterationsMax);else if(J*1.1>=this._minDt*2)this._iterationsMin=Math.max(Math.floor(this._iterationsMin/2),1),this._iterationsMax=Math.max(Math.floor(this._iterationsMax/2),2);else if(J*1.1>=this._minDt)this._iterationsMax=Math.ceil(this._iterationsMax*0.67),this._iterationsMin=Math.min(this._iterationsMax-1,this._iterationsMin);return this._minDt=Math.min(this._minDt,J),this._lastTime=h,Math.max(Math.floor((this._iterationsMax+this._iterationsMin)/2),1)}launchGTSolve(){if(!this._solver||this._solver.solving||!this._problem)return;if(this._startTime=Date.now(),this._testedSolutions=0n,this._prunedSolutions=0n,this._minDt=Number.MAX_SAFE_INTEGER,this._iterationsMin=1,this._iterationsMax=1000,this._handleRefreshStats===null)this._handleRefreshStats=setInterval(()=>{this._statsDisplay?.display()},500);if(this._solverSteps=(h)=>{let J=null;for(let M=0;M<h;M++){const[W,q]=this._gtIterator.next().value;if(J=W,this._testedSolutions++,q){this._gtIterator=null;break}}if(J)this._problem.setAffectation(J)},this._gtIterator===null)this._gtIterator=this._solver.gt(!0,!0);this._animateSolve(1000)}_animateSolve(h){if(this._solverSteps){if(this._solverSteps(this._computeSolvingIterations(h)),this._refreshGrid(),this._solver?.solving)requestAnimationFrame(this._animateSolve.bind(this))}}static create(h){const J=B(h);if(J===null)return null;const M=K.get(J.canvas);if(!M)return null;return new N(M,J)}}var Jh="sudokuCanvas",Mh="solutionsSpaceSize",Wh="reset",qh="GT",Qh="BT",Yh="NC",$h="ACNone",Kh="AC1",Lh="AC3",Xh="testedSolutions",Zh="prunedSolutions",wh="progress",Hh="timeleft";C();var r=N.create({canvasId:Jh,solutionSpaceSizePId:Mh,resetBtnId:Wh,gtBtnId:qh,btBtnId:Qh,ncCheckboxId:Yh,acNoneRadioId:$h,ac1RadioId:Kh,ac3RadioId:Lh,testedSolutionsPId:Xh,prunedSolutionsPId:Zh,progressPId:wh,timeleftPId:Hh});r&&r.start();
